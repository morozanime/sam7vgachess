/* ----------------------------------------------------------------------------
 *         ATMEL Microcontroller Software Support 
 * ----------------------------------------------------------------------------
 * Copyright (c) 2008, Atmel Corporation
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the disclaimer below.
 *
 * Atmel's name may not be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 */

//------------------------------------------------------------------------------
/// \dir "Getting Started with AT91SAM Microcontrollers"
///
/// !!!Purpose
///
/// The Getting Started project will help new users get familiar with Atmel's
/// AT91 family of microcontrollers. This basic application shows the startup
/// sequence of a chip and how to use its core peripherals.
///
/// !!!Requirements
///
/// This package can be used with all Atmel evaluation kits.
///
/// !!!Description
///
/// The demonstration program makes two LEDs on the board blink at a fixed rate.
/// This rate is generated by using a timer for the first LED; the second one
/// uses a Wait function based on a 1 ms tick. The blinking can be stopped using
/// two buttons (one for each LED).
///
/// !!!Usage
///
/// -# Build the program and download it inside the evaluation board. Please
///    refer to the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6224.pdf">SAM-BA User Guide</a>,
///    the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6310.pdf">GNU-Based Software Development</a>
///    application note or to the <a href="ftp://ftp.iar.se/WWWfiles/arm/Guides/EWARM_UserGuide.ENU.pdf">IAR EWARM User Guide</a>,
///    depending on your chosen solution.
/// -# On the computer, open and configure a terminal application
///    (e.g. HyperTerminal on Microsoft Windows) with these settings:
///   - 115200 bauds
///   - 8 bits of data
///   - No parity
///   - 1 stop bit
///   - No flow control
/// -# Start the application.
/// -# Two LEDs should start blinking on the board. In the terminal window, the
///    following text should appear (values depend on the board and chip used):
///    \code
///     -- Getting Started Project xxx --
///     -- AT91xxxxxx-xx
///     -- Compiled: xxx xx xxxx xx:xx:xx --
///    \endcode
/// -# Pressing button 1 should make the first LED stop & restart blinking; same
///    for button 2 with the second LED.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
/// \unit
///
/// !Purpose
///
/// This file contains all the specific code for the getting-started-project.
///
/// !Contents
/// The code can be roughly broken down as follows:
///    - Configuration functions
///    - Interrupt handlers
///    - Utility functions (such as Wait())
///    - The main() function, which implements the program behavior
///
/// !Description
/// -#  Interrupt: for at91sam7xxx and at91sam9xxx microcontrollers, the interrupt is managed by AIC, for at91sam3xxx
///     microcontrollers, the interrupt is managed by cortex-m3's NVIC. The API for AIC and NVIC is the same, the detail 
///     usage can be  found in the code.
/// -#  Time tick: for at91sam7xxx and at91sam9xxx microcontrollers, the time tick is generated by PIT,  for at91sam3xxx
///     microcontrollers, the time tick is generated by cortex-m3's system tick. The PIT and system tick are excluded, so we
///     should use the correct time tick for the individual microcontrollers. the detail usage can be found in the code.
/// -#  Timer: timer is the same for all the at91 microcontrollers.
/// -#  LED and Button: LED and button is configured by the PIO, the usages are the same for all the at91 microcontrollers.
///
/// Please refer to the list of functions in the #Overview# tab of this unit
/// for more detailed information.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//         Headers
//------------------------------------------------------------------------------
#include 	"main.h"
//#include	"mylcd.h"
//#include	"life.h"
#include 	"8X8WIN1251.h"
#include    "chess.h"
#include 	"chess48.h"
#include 	"ps2mouse.h"

const Pin pinLCD_RESET = LCD_RESET;
const Pin pinLCD_A0 = LCD_A0;
const Pin pinLCD_LED = LCD_LED;
const Pin pinsLCD[] = { PINS_LCD };
const Pin pinsSPI0[] = { PINS_SPI0 };
const Pin pinsSPI1[] = { PINS_SPI1 };

#define	TC0_OCA		{1 << 23, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
//#define	TC0_OCB		{1 << 24, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
#define	VGA_VSYNC	{1 << 25, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_OUTPUT_1, PIO_DEFAULT}
#define	VGA_RED		{1 << 24, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT}
//#define	VGA_GREEN	{1 << 26, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT}
const Pin pinVGA_VSYNC = VGA_VSYNC;
const Pin pinsVGA[] = { TC0_OCA, VGA_RED, VGA_VSYNC };

//------------------------------------------------------------------------------
//         Local definitions
//------------------------------------------------------------------------------

/// Delay for pushbutton debouncing (in milliseconds).
#define DEBOUNCE_TIME       500

#if defined(AT91C_BASE_PITC)
/// PIT period value in µseconds.
#define PIT_PERIOD          1000
#endif

//------------------------------------------------------------------------------
//         Local variables
//------------------------------------------------------------------------------

/// Pushbutton \#1 pin instance.
//const Pin pinPB1 = PIN_PUSHBUTTON_1;

/// Pushbutton \#1 pin instance.
//const Pin pinPB2 = PIN_PUSHBUTTON_2;

/// Indicates the current state (on or off) for each LED.
volatile unsigned char pLedStates[2] = { 1, 1 };

/// Global timestamp in milliseconds since start of application.
volatile unsigned int timestamp = 0;

//------------------------------------------------------------------------------
//         Local functions
//------------------------------------------------------------------------------

#if defined(AT91C_BASE_PITC)
//------------------------------------------------------------------------------
/// Handler for PIT interrupt. Increments the timestamp counter.
//------------------------------------------------------------------------------
void ISR_Pit(void) {
	unsigned int status;

	// Read the PIT status register
	status = PIT_GetStatus() & AT91C_PITC_PITS;
	if (status != 0) {
		// 1 = The Periodic Interval timer has reached PIV since the last read of PIT_PIVR.
		// Read the PIVR to acknowledge interrupt and get number of ticks
		//Returns the number of occurrences of periodic intervals since the last read of PIT_PIVR.
		timestamp += (PIT_GetPIVR() >> 20);
	}
//    LED_Toggle(1);
}

//------------------------------------------------------------------------------
/// Configure the periodic interval timer (PIT) to generate an interrupt every
/// millisecond.
//------------------------------------------------------------------------------
void ConfigurePit(void) {
	// Initialize the PIT to the desired frequency
	PIT_Init(PIT_PERIOD, BOARD_MCK / 1000000);

	// Configure interrupt on PIT
	IRQ_DisableIT(AT91C_ID_SYS);
	IRQ_ConfigureIT(AT91C_ID_SYS, AT91C_AIC_PRIOR_LOWEST, ISR_Pit);
	IRQ_EnableIT(AT91C_ID_SYS);
	PIT_EnableIT();

	// Enable the pit
	PIT_Enable();
}
#else

//------------------------------------------------------------------------------
/// Handler for Sytem Tick interrupt. Increments the timestamp counter.
//------------------------------------------------------------------------------
void SysTick_Handler(void)
{
	timestamp++;
}
#endif

//------------------------------------------------------------------------------
/// Interrupt handler for pushbutton\#1. Starts or stops LED\#1.
//------------------------------------------------------------------------------
//void ISR_Bp1(void) {
//	static unsigned int lastPress = 0;
//
//	// Check if the button has been pressed
//	if (!PIO_Get(&pinPB1)) {
//
//		// Simple debounce method: limit push frequency to 1/DEBOUNCE_TIME
//		// (i.e. at least DEBOUNCE_TIME ms between each push)
//		if ((timestamp - lastPress) > DEBOUNCE_TIME) {
//
//			lastPress = timestamp;
//
//			// Toggle LED state
//			pLedStates[0] = !pLedStates[0];
//			if (!pLedStates[0]) {
//
//				LED_Clear(0);
//			}
//		}
//	}
//}

//------------------------------------------------------------------------------
/// Interrupt handler for pushbutton\#2. Starts or stops LED\#2 and TC0.
//------------------------------------------------------------------------------
//void ISR_Bp2(void) {
//	static unsigned int lastPress = 0;
//
//	// Check if the button has been pressed
//	if (!PIO_Get(&pinPB2)) {
//
//		// Simple debounce method: limit push frequency to 1/DEBOUNCE_TIME
//		// (i.e. at least DEBOUNCE_TIME ms between each push)
//		if ((timestamp - lastPress) > DEBOUNCE_TIME) {
//
//			lastPress = timestamp;
//
//			// Disable LED#2 and TC0 if there were enabled
//			if (pLedStates[1]) {
//
//				pLedStates[1] = 0;
//				LED_Clear(1);
//				AT91C_BASE_TC0->TC_CCR = AT91C_TC_CLKDIS;
//			}
//			// Enable LED#2 and TC0 if there were disabled
//			else {
//
//				pLedStates[1] = 1;
//				LED_Set(1);
//				AT91C_BASE_TC0->TC_CCR = AT91C_TC_CLKEN | AT91C_TC_SWTRG;
//			}
//		}
//	}
//}

//------------------------------------------------------------------------------
/// Configures the pushbuttons to generate interrupts when pressed.
//------------------------------------------------------------------------------
//void ConfigureButtons(void) {
//#if defined(at91sam7lek)
//	const Pin pinCol0 = PIN_KEYBOARD_COL0;
//	PIO_Configure(&pinCol0, 1);
//#endif
//
//#if defined(at91cap9dk)
//	const Pin pinRow0 = PIN_KEYBOARD_ROW0;
//	PIO_Configure(&pinRow0, 1);
//#endif
//
//	// Configure pios
//	PIO_Configure(&pinPB1, 1);
//	PIO_Configure(&pinPB2, 1);
//
//	// Initialize interrupts
//	PIO_InitializeInterrupts(0);
//	PIO_ConfigureIt(&pinPB1, (void (*)(const Pin *)) ISR_Bp1);
//	PIO_ConfigureIt(&pinPB2, (void (*)(const Pin *)) ISR_Bp2);
//	PIO_EnableIt(&pinPB1);
//	PIO_EnableIt(&pinPB2);
//}

//------------------------------------------------------------------------------
/// Configures LEDs \#1 and \#2 (cleared by default).
//------------------------------------------------------------------------------
void ConfigureLeds(void) {
//	LED_Configure(0);
//	LED_Configure(1);
}

//------------------------------------------------------------------------------
/// Interrupt handler for TC0 interrupt. Toggles the state of LED\#2.
//------------------------------------------------------------------------------
uint8_t textBuff[480 / 8][640 / 8];
uint8_t chessBoard[8][8] = {		//
		//
				{ ROOK | BLACK, KNIGHT | BLACK, BISHOP | BLACK, QUEEN | BLACK, KING | BLACK, BISHOP | BLACK, KNIGHT | BLACK, ROOK | BLACK },//
				{ PAWN | BLACK, PAWN | BLACK, PAWN | BLACK, PAWN | BLACK, PAWN | BLACK, PAWN | BLACK, PAWN | BLACK, PAWN | BLACK },		//
				{ EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY },	//
				{ EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY },	//
				{ EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY },	//
				{ EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY },	//
				{ PAWN | WHITE, PAWN | WHITE, PAWN | WHITE, PAWN | WHITE, PAWN | WHITE, PAWN | WHITE, PAWN | WHITE, PAWN | WHITE },		//
				{ ROOK | WHITE, KNIGHT | WHITE, BISHOP | WHITE, QUEEN | WHITE, KING | WHITE, BISHOP | WHITE, KNIGHT | WHITE, ROOK | WHITE },//
		};

uint32_t chessBoardSpriteAddr[8][8];

uint8_t mouseIcon[] = {		//
		//
				0x00, 0x00, 0x00, 0xe0, //
				0x00, 0x40, 0x00, 0xf0, //
				0x00, 0x60, 0x00, 0xf8, //
				0x00, 0x50, 0x00, 0xfc, //
				0x00, 0x48, 0x00, 0xfe, //
				0x00, 0x44, 0x00, 0xff, //
				0x00, 0x42, 0x80, 0xff, //
				0x00, 0x41, 0xc0, 0xff, //
				0x80, 0x40, 0xe0, 0xff, //
				0x40, 0x40, 0xf0, 0xff, //
				0x20, 0x40, 0xf8, 0xff, //
				0x10, 0x40, 0xfc, 0xff, //
				0xf8, 0x40, 0xfc, 0xff, //
				0x80, 0x44, 0xfc, 0xff, //
				0x80, 0x4c, 0xe0, 0xff, //
				0x40, 0x52, 0xe0, 0xff, //
				0x40, 0x62, 0xf0, 0xff, //
				0x20, 0x41, 0xf0, 0xf7, //
				0x20, 0x01, 0xf8, 0xe3, //
				0x90, 0x00, 0xf8, 0x03, //
				0x90, 0x00, 0xf8, 0x01, //
				0x60, 0x00, 0xf8, 0x01, //
				0x00, 0x00, 0xf0, 0x00, //
		/**/
//				0x80, 0x00, 0xfe, 0x00,	//
//				0x7c, 0x00, 0xfe, 0x00, //
//				0x78, 0x00, 0xfc, 0x00, //
//				0x70, 0x00, 0xf8, 0x00, //
//				0x68, 0x00, 0xfc, 0x00, //
//				0x44, 0x00, 0xfe, 0x00, //
//				0x02, 0x00, 0x07, 0x00, //
//				0x01, 0x00, 0x03, 0x80, //
//				0x00, 0x80, 0x01, 0xc0, //
//				0x00, 0x78, 0x00, 0xfc, //
//				0x00, 0x60, 0x00, 0xf0, //
//				0x00, 0x50, 0x00, 0xf8, //
//				0x00, 0x48, 0x00, 0xfc, //
//				0x00, 0x04, 0x00, 0x0e, //
//				0x00, 0x02, 0x00, 0x07, //
//				0x00, 0x01, 0x00, 0x03, //
		};

struct {
	uint16_t chessboard_Xpos;
	uint16_t chessboard_Ypos;
	uint16_t mouseXpos;
	uint16_t mouseYpos;
} driverSettings = { 1, 16, 136, 48 * 3 + 49 };

void TC0_IrqHandler(void) {
	static int scanLine = 0;
	static int pline = 0;
	static int row = 0;
	// Clear status bit to acknowledge interrupt
	AT91C_BASE_TC0->TC_SR;

	if (scanLine < 480) {
		static uint8_t scanLineBufferA[640 / 8 + 2];
		static uint8_t scanLineBufferB[640 / 8 + 2];
		static uint8_t * scanLineBufferIndex = scanLineBufferA;
//		if (!(AT91C_BASE_TC0->TC_CV & 1))
//			AT91C_BASE_TC0->TC_CV;

		AT91C_BASE_SPI1->SPI_TPR = (uint32_t) scanLineBufferIndex;
		AT91C_BASE_SPI1->SPI_TCR = 640 / 8;
		AT91C_BASE_SPI1->SPI_PTCR = AT91C_PDC_TXTEN;
		scanLineBufferIndex = (scanLine & 1) ? scanLineBufferA : scanLineBufferB;
		int l = scanLine + 1;
		if (l >= 480)
			l = 0;

		if (l == driverSettings.chessboard_Ypos)
			row = 0;
		/*display text 8x8*/
		int charRow = l & 7;
		int buffLine = l >> 3;
		int buffOffset = 0;
		for (int i = 0; i < driverSettings.chessboard_Xpos; i++) {
			*(uint32_t*) (scanLineBufferIndex + buffOffset + 0) = font8x8win1251[textBuff[buffLine][buffOffset + 0] * 8 + charRow]
					+ (font8x8win1251[textBuff[buffLine][buffOffset + 1] * 8 + charRow] << 8)
					+ (font8x8win1251[textBuff[buffLine][buffOffset + 2] * 8 + charRow] << 16)
					+ (font8x8win1251[textBuff[buffLine][buffOffset + 3] * 8 + charRow] << 24);
			buffOffset += 4;
		}
		if (row < 8) {
			for (int col = 0; col < 8; col++) {
				uint32_t x = chessBoardSpriteAddr[row][col];
				uint16_t pattern = (uint16_t) (((row ^ col) & 1) ? (0xEEEEEEEE >> (pline & 3)) : 0xFFFF);
				if (x) {
					int boffset = x + pline * 36;
					*(uint16_t*) (scanLineBufferIndex + buffOffset + 0) = *(uint16_t*) (boffset + 0) & pattern;
					*(uint16_t*) (scanLineBufferIndex + buffOffset + 2) = *(uint16_t*) (boffset + 2) & pattern;
					*(uint16_t*) (scanLineBufferIndex + buffOffset + 4) = *(uint16_t*) (boffset + 4) & pattern;
				} else {
					*(uint16_t*) (scanLineBufferIndex + buffOffset + 0) = pattern;
					*(uint16_t*) (scanLineBufferIndex + buffOffset + 2) = pattern;
					*(uint16_t*) (scanLineBufferIndex + buffOffset + 4) = pattern;
				}
				buffOffset += 6;
			}

			pline++;
			if (pline >= 48) {
				pline = 0;
				row++;
			}
		}

		while (buffOffset < (640 / 8)) {
			uint32_t x = font8x8win1251[textBuff[buffLine][buffOffset + 0] * 8 + charRow]
					+ (font8x8win1251[textBuff[buffLine][buffOffset + 1] * 8 + charRow] << 8)
					+ (font8x8win1251[textBuff[buffLine][buffOffset + 2] * 8 + charRow] << 16)
					+ (font8x8win1251[textBuff[buffLine][buffOffset + 3] * 8 + charRow] << 24);
			*(uint32_t*) (scanLineBufferIndex + buffOffset + 0) = x;
			buffOffset += 4;
		}

		int mouseLine = l - driverSettings.mouseYpos;
		if ((mouseLine >= 0) && (mouseLine < 23)) {
			int byteOffset = driverSettings.mouseXpos >> 3;
			int bitOffset = driverSettings.mouseXpos - (byteOffset << 3);
			uint32_t a = scanLineBufferIndex[byteOffset + 2] + (scanLineBufferIndex[byteOffset + 1] << 8)
					+ (scanLineBufferIndex[byteOffset + 0] << 16);
			a &= ~(((uint32_t) (*(uint16_t*) (mouseIcon + mouseLine * 4 + 2)) << 8) >> bitOffset);
			a |= ((uint32_t) (*(uint16_t*) (mouseIcon + mouseLine * 4 + 0)) << 8) >> bitOffset;
			scanLineBufferIndex[byteOffset + 2] = (uint8_t) (a >> 0);
			scanLineBufferIndex[byteOffset + 1] = (uint8_t) (a >> 8);
			scanLineBufferIndex[byteOffset + 0] = (uint8_t) (a >> 16);
		}

		/*display bitmap 288x96*/
//		int boffset = l * (288 / 8);
//		for (int p = 0; p < 7; p++) {
//			for (int i = 0; i < 6; i++) {
//				uint8_t b = chess48[boffset + p * 6 + i];
//				if (p & 1)
//					b &= (uint8_t) (0xEEDDBB77 >> (l & 3));
//				scanLineBufferIndex[p * 6 + i] = b;
//			}
//		}
//		memcpy(scanLineBufferIndex, chess48 + boffset, 288 / 8);
	} else if (scanLine < 480 + 11) {
	} else if (scanLine == 480 + 11) {
		AT91C_BASE_PIOB->PIO_CODR = 1 << 25;		//VGA_VSYNC
	} else if (scanLine == 480 + 11 + 2) {
		AT91C_BASE_PIOB->PIO_SODR = 1 << 25;		//VGA_VSYNC
	} else if (scanLine < 480 + 11 + 2 + 32) {

	} else {
		scanLine = -1;
	}
	scanLine++;
	AT91C_BASE_PIOB->PIO_SODR = 1 << 24;
	AT91C_BASE_PIOB->PIO_CODR = 1 << 24;
}

//------------------------------------------------------------------------------
/// Configure Timer Counter 0 to generate an interrupt every 250ms.
//------------------------------------------------------------------------------
void ConfigureTc(void) {
	unsigned int div;
	unsigned int tcclks;
	PIO_Configure(pinsVGA, PIO_LISTSIZE(pinsVGA));

// Enable peripheral clock
	AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_TC0;

// Configure TC for a 4Hz frequency and trigger on RC compare
//	TC_FindMckDivisor(31476, BOARD_MCK, &div, &tcclks);
	div = 2;
	tcclks = 0;
	TC_Configure(AT91C_BASE_TC0,
			tcclks | AT91C_TC_CPCTRG | AT91C_TC_WAVE | AT91C_TC_WAVESEL_UP_AUTO | AT91C_TC_ACPA_SET | AT91C_TC_ACPC_CLEAR
			/*| AT91C_TC_BCPB_SET | AT91C_TC_BCPC_CLEAR | AT91C_TC_EEVT_XC0*/);
	AT91C_BASE_TC0->TC_RA = (BOARD_MCK * 10U / div) / 31476U / 84U;
//	AT91C_BASE_TC0->TC_RB = (BOARD_MCK * 10U / div) / 31476U / 55U;
	AT91C_BASE_TC0->TC_RC = (BOARD_MCK / div) / 31476U; // timerFreq / desiredFreq

// Configure and enable interrupt on RC compare
	IRQ_ConfigureIT(AT91C_ID_TC0, AT91C_AIC_PRIOR_HIGHEST, TC0_IrqHandler);
	AT91C_BASE_TC0->TC_IER = AT91C_TC_CPAS;
	IRQ_EnableIT(AT91C_ID_TC0);

	TC_Start(AT91C_BASE_TC0);
}

//------------------------------------------------------------------------------
/// Waits for the given number of milliseconds (using the timestamp generated
/// by the SAM7 & SAM9 microcontrollers's PIT, or SAM3's microcontrollers's system tick).
/// \param delay  Delay to wait for, in milliseconds.
//------------------------------------------------------------------------------
void _delay_ms(unsigned long delay) {
	volatile unsigned int start = timestamp;
	unsigned int elapsed;
	do {
		elapsed = timestamp;
		elapsed -= start;
	} while (elapsed < delay);
}

//------------------------------------------------------------------------------
//         Exported functions
//------------------------------------------------------------------------------

void scrollUp(void) {
	for (int i = 0; i < 480 / 8 - 1; i++)
		for (int j = 0; j < 640 / 8; j++)
			textBuff[i][j] = textBuff[i + 1][j];
	memset((void*) (&textBuff[480 / 8 - 1][0]), 0, 640 / 8);
}

void putChar(char c) {
	static int line = 0;
	static int pos = 0;
	if (c == 0x0d)
		pos = 0;
	else if (c == 0x0a) {
		pos = 0;
		if (line >= 480 / 8 - 1)
			scrollUp();
		else
			line++;
	} else {
		if (pos >= 640 / 8 - 1) {
			pos = 0;
			if (line >= 480 / 8 - 1)
				scrollUp();
			else
				line++;
			textBuff[line][pos] = c;
		} else
			textBuff[line][pos++] = c;
	}
}

void putString(char * str) {
	while (*str)
		putChar(*(str++));
}

void print_chess_board(void) {
	for (int i = 0; i < 8; i++) {
		if (driverSettings.chessboard_Ypos >= 8)
			textBuff[driverSettings.chessboard_Ypos / 8 - 1][i * 6 + driverSettings.chessboard_Xpos * 4 + 2] = 'A' + i;
		if (driverSettings.chessboard_Ypos <= (480 - 8 * 6 * 8 - 8))
			textBuff[6 * 8 + driverSettings.chessboard_Ypos / 8][i * 6 + driverSettings.chessboard_Xpos * 4 + 2] = 'A' + i;
		if (driverSettings.chessboard_Xpos > 0)
			textBuff[6 * 8 + driverSettings.chessboard_Ypos / 8 - 3 - i * 6][driverSettings.chessboard_Xpos * 4 - 1] = '1' + i;
		if (driverSettings.chessboard_Xpos < (640 - 8 * 6 * 8) / 8 / 4)
			textBuff[6 * 8 + driverSettings.chessboard_Ypos / 8 - 3 - i * 6][6 * 8 + driverSettings.chessboard_Xpos * 4] = '1' + i;
	}
	putString("Hello, World!");
}

//------------------------------------------------------------------------------
/// Application entry point. Configures the DBGU, PIT for SAM7 & SAM9 
/// microcontrollers, UART and System tick for SAM3 microcontrollers.
/// Configures TC0, LEDs and buttons and makes LED\#1 blink in its infinite 
/// loop, using the Wait function.
/// \return Unused (ANSI-C compatibility).
//------------------------------------------------------------------------------
int main(void) {
// DBGU output configuration
	TRACE_CONFIGURE(DBGU_STANDARD, 115200, BOARD_MCK);
	printf("-- Getting Started Project %s --\n\r", SOFTPACK_VERSION);
	printf("-- %s\n\r", BOARD_NAME);
	printf("-- Compiled: %s %s --\n\r", __DATE__, __TIME__);

// Configuration
#if defined(AT91C_BASE_PITC)
	TRACE_INFO("configure pit.\n\r");
	ConfigurePit();
#else
// 1ms tick
	TRACE_INFO("configure sys tick.\n\r");
	SysTick_Configure(1, BOARD_MCK/1000, SysTick_Handler);
#endif

	ConfigureTc();
//    ConfigureButtons();
//	ConfigureLeds();

	PIO_Configure(pinsLCD, PIO_LISTSIZE(pinsLCD));

	PIO_Configure(pinsSPI0, PIO_LISTSIZE(pinsSPI0));
	SPI_Configure(AT91C_BASE_SPI0, AT91C_ID_SPI0,
	AT91C_SPI_MSTR | AT91C_SPI_MODFDIS | (SPI_PCS(3)));
	SPI_ConfigureNPCS(AT91C_BASE_SPI0, 3,
	AT91C_SPI_BITS_8 /*| AT91C_SPI_CSAAT | AT91C_SPI_NCPHA*/| (2 << 8));
	SPI_Enable(AT91C_BASE_SPI0);

	PIO_Configure(pinsSPI1, PIO_LISTSIZE(pinsSPI1));

	SPI_Configure(AT91C_BASE_SPI1, AT91C_ID_SPI1,
	AT91C_SPI_MSTR | AT91C_SPI_MODFDIS/* | (SPI_PCS(0))*/);
	AT91C_BASE_SPI1->SPI_PTCR = AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS;
	AT91C_BASE_SPI1->SPI_TNPR = 0;
	AT91C_BASE_SPI1->SPI_TNCR = 0;
	AT91C_BASE_SPI1->SPI_RNPR = 0;
	AT91C_BASE_SPI1->SPI_RNCR = 0;
	AT91C_BASE_SPI1->SPI_TPR = 0;
	AT91C_BASE_SPI1->SPI_TCR = 0;
	AT91C_BASE_SPI1->SPI_RPR = 0;
	AT91C_BASE_SPI1->SPI_RCR = 0;

	SPI_ConfigureNPCS(AT91C_BASE_SPI1, 0, AT91C_SPI_BITS_8 | (3 << 8));
	SPI_Enable(AT91C_BASE_SPI1);

//	LCD_Init_Splash();

//	LCD_Init();                            // Reconfigure LCD for normal use
//	LCD_draw_rect_filled(0, 128, 0, 128, 0x0000);
//	LCD_draw_rect_filled(10, 118, 10, 118, 0xFFFF);

// Main loop

	ps2Init();
	ps2Write(0xff);
	ps2Read();
	ps2Read();
	ps2Read();
	ps2Write(0xf0);
	ps2Read();
	ps2DelayUs(100);

	chess_init();
	while (1) {

//		printf("A=%08X\n\r", AT91C_BASE_PIOA->PIO_PDSR);
	}
}

int getMove_mouse(void) {
	int dx, dy;
	int result = 0;
	ps2Write(0xeb);
	ps2Read();
	uint8_t a;
	a = ps2Read();
	dx = (int8_t) ps2Read();
	dy = (int8_t) ps2Read();
	int x = driverSettings.mouseXpos + dx;
	int y = driverSettings.mouseYpos - dy;
	if (x < 0)
		x = 0;
	else if (x > 640 - 3)
		x = 640 - 3;
	driverSettings.mouseXpos = (uint16_t) x;
	if (y < 0)
		y = 0;
	else if (y > 480 - 3)
		y = 480 - 3;
	driverSettings.mouseYpos = (uint16_t) y;
	static uint8_t btns = 0;
	if (a & (a ^ btns) & 1) {
//		printf("LB: ");
		if (driverSettings.mouseXpos >= driverSettings.chessboard_Xpos * 32
				&& driverSettings.mouseXpos < (driverSettings.chessboard_Xpos * 32 + 6 * 8 * 8)
				&& driverSettings.mouseYpos >= driverSettings.chessboard_Ypos
				&& driverSettings.mouseYpos < (driverSettings.chessboard_Ypos + 6 * 8 * 8)) {
			result = (((driverSettings.mouseXpos - driverSettings.chessboard_Xpos * 32) / (6 * 8) + 'a') << 8)
					+ (-(driverSettings.mouseYpos - driverSettings.chessboard_Ypos) / (6 * 8) + '8');
//			printf("%c%c\n\r", (uint8_t) (result >> 8), (uint8_t) result);
		}
	} else if (a & (a ^ btns) & 2) {
		result = -1;
	}
	btns = a;
	return result;
}

void panel_init(void) {
}

VOID sound_yourmove() {

}

BOOL panel_getmove(LOC from, LOC to) {
	char buff[4];
	int a = getMove_mouse();
	if (a > 0) {
		buff[0] = (char) (a >> 8);
		buff[1] = (char) a;
	} else
		return FALSE;
	putChar(buff[0]);
	putChar(buff[1]);
	do {
		a = getMove_mouse();
		if(a < 0){
			putChar(';');
			return FALSE;
		}
		if (a > 0) {
			buff[2] = (char) (a >> 8);
			buff[3] = (char) a;
			break;
		}
	} while (a == 0);
	putChar('-');
	putChar(buff[2]);
	putChar(buff[3]);
	putChar(',');
//
//	buff[0] = DBGU_GetChar();
//	printf("%c", buff[0]);
//	putChar(buff[0]);
//	buff[1] = DBGU_GetChar();
//	printf("%c", buff[1]);
//	putChar(buff[1]);
//	buff[2] = DBGU_GetChar();
//	printf("%c", buff[2]);
//	putChar(buff[2]);
//	buff[3] = DBGU_GetChar();
//	printf("%c", buff[3]);
//	putChar(buff[3]);

	from[1] = buff[0] - 'a';
	from[0] = buff[1] - '1';
	to[1] = buff[2] - 'a';
	to[0] = buff[3] - '1';
	return TRUE;
}

VOID sound_illegal() {
}

VOID panel_draw(COORD row, COORD col, PIECE p) {
//	char a[] = " PRHBQK";
//	textBuff[(7 - row) * 2 + 2][col * 2 + 50] = a[p & 7] + ((p & 8) ? 0x20 : 0);
	chessBoard[7 - row][col] = p;
	chessBoardSpriteAddr[7 - row][col] = p ? chess48_map[p] + (uint32_t) &chess48[0] : 0;
//	printf("panel_draw [%d,%d]:%d\n", row, col, p);
}

VOID sound_capture() {
//	printf("sound_capture\n");
}

VOID panel_cls(VOID) {
	memset((void*) textBuff, ' ', sizeof(textBuff));
	print_chess_board();
}
